
import dotenv from 'dotenv';
import Redis from 'ioredis';

dotenv.config({ path: '.env.local' });

const getRedisUrl = () => {
    if (process.env.REDIS_URL) {
        return process.env.REDIS_URL;
    }
    return 'redis://localhost:6379';
};

const redis = new Redis(getRedisUrl());

async function clearResistanceCache() {
    console.log('--- CLEARING RESISTANCE CACHE ---');

    // 1. Clear explicit resistance result keys
    const keys = await redis.keys('resistance_*');
    if (keys.length > 0) {
        console.log(`Deleting ${keys.length} resistance keys:`, keys);
        await redis.del(...keys);
        console.log('âœ… Resistance keys deleted.');
    } else {
        console.log('No direct "resistance_*" keys found.');
    }

    // 2. Clear old traces from 'sources' key
    // We need to check if sources are stored per user or global.
    // In `useSources.ts`, it seems to fetch `/api/sources`.
    // Looking at `api/sources/route.ts` (implied), it likely uses a key like `sources` or `sources_${userId}`.

    // Let's try to find source keys
    const sourceKeys = await redis.keys('*sources*');
    console.log('Found source keys:', sourceKeys);

    for (const key of sourceKeys) {
        const type = await redis.type(key);
        if (type !== 'string') continue; // Should be JSON string

        const data = await redis.get(key);
        if (!data) continue;

        try {
            const sources = JSON.parse(data);
            if (!Array.isArray(sources)) continue;

            const initialCount = sources.length;
            // Filter out traces that are specifically 'resistance' traces
            // OR old generic traces that were generated by the resistance page (if previously untagged)
            // Since we just added the tag, old ones might not have it.
            // Safest Logic: Remove traces where `traceType === 'resistance'`.
            // User asked to clear for "new micro-resistance", so removing potentially conflicting old data is good.

            const newSources = sources.filter(s => {
                // Delete if explicitly resistance
                if (s.traceType === 'resistance') return false;

                // Optional: Also delete generic Traces if they don't have a linked PolicyID ? 
                // No, let's stick to strict `traceType` if possible, or if user wants "fresh start", 
                // maybe we delete ALL traces linked to resistance page logic.
                // Given the previous step just added the tag, old resistance traces have NO tag and `type: Trace`.
                // But Data/Empirical traces also have `type: Trace`.
                // So we can only safely delete ones where we are sure.

                // However, since we just implemented the tagging, existing traces in Redis likely DON'T have the tag yet.
                // If the user wants a CLEAN SLATE for resistance, we should probably delete untagged Traces that look like resistance noise?
                // Or just delete ALL explicit keys and let the user delete traces manually?

                // Decision: Only delete if `traceType === 'resistance'`. 
                // The user can manually delete old "un-tagged" traces if they want, or we can assume they are empty.
                // Actually, since I just added the tag code, NO traces in the DB have `traceType: 'resistance'` yet unless I just created them.
                // So this script mostly ensures future cleanups or if I ran some tests.

                return true;
            });

            if (newSources.length !== initialCount) {
                console.log(`Removing ${initialCount - newSources.length} resistance traces from ${key}`);
                await redis.set(key, JSON.stringify(newSources));
            } else {
                console.log(`No resistance traces found to purge in ${key}`);
            }

        } catch (e) {
            console.error(`Error processing key ${key}:`, e);
        }
    }

    console.log('--- CACHE CLEAR COMPLETE ---');
    redis.disconnect();
}

clearResistanceCache();
