import { jsPDF } from "jspdf";
import { Source } from "../types";

// --- Configuration ---

const STYLE = {
    margin: 20,
    fonts: {
        normal: "helvetica",
        bold: "helvetica", // jsPDF uses 'helvetica' with font style 'bold'
    },
    colors: {
        primary: [15, 23, 42] as [number, number, number],   // Slate 900
        secondary: [51, 65, 85] as [number, number, number], // Slate 700
        text: [0, 0, 0] as [number, number, number],         // Black
        meta: [100, 116, 139] as [number, number, number],   // Slate 500
        subtle: [150, 150, 150] as [number, number, number], // Gray
        accentBG: [241, 245, 249] as [number, number, number], // Slate 100
        cardBG: [248, 250, 252] as [number, number, number],   // Slate 50
        line: [203, 213, 225] as [number, number, number],     // Slate 300
    },
    sizes: {
        title: 24,
        header: 16,
        section: 12,
        subHeader: 11,
        body: 10,
        meta: 9,
        small: 8,
    },
    spacing: {
        lineHeight: 1.3,
        paragraph: 3,
        section: 10,
    }
};

// --- Helper Functions ---

/**
 * Sanitizes text to remove markdown, fix smart quotes, and repair broken spacing.
 */
function sanitizeText(text: string): string {
    if (!text) return "";

    // 1. Basic Character Normalization (Smart Quotes, Dashes, etc.)
    let clean = text
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u201C\u201D]/g, '"')
        .replace(/[\u2013\u2014]/g, "-")
        .replace(/\u2026/g, "...")
        .replace(/[\u00A0\u200B\u202F\u205F]/g, " ");

    // 2. Markdown Removal
    clean = clean
        .replace(/\*\*/g, "")
        .replace(/^#+\s/gm, "")
        .replace(/`/g, "")
        .replace(/\[(.*?)\]\(.*?\)/g, "$1") // Links: [text](url) -> text
        .replace(/\*/g, ""); // Stray asterisks

    // 3. Heuristic Wide Text Repair (Fixing "s p a c e d" text)
    // Protect valid double spaces
    clean = clean.replace(/  +/g, "###SPACE###");
    // Collapse "c h a r " sequences
    clean = clean.replace(/([a-zA-Z0-9,.] )([a-zA-Z0-9,.] )+[a-zA-Z0-9,.]/g, (match) => {
        if (match.includes("###SPACE###")) return match;
        return match.replace(/ /g, "");
    });
    // Restore valid spaces
    clean = clean.replace(/###SPACE###/g, " ");

    // 4. Normalize Bullets
    clean = clean.replace(/^- /gm, "• ");

    return clean;
}

// --- Report Generator Class ---

class ReportGenerator {
    private doc: jsPDF;
    private y: number;
    private pageWidth: number;
    private pageHeight: number;
    private contentWidth: number;

    constructor() {
        this.doc = new jsPDF();
        this.pageWidth = this.doc.internal.pageSize.getWidth();
        this.pageHeight = this.doc.internal.pageSize.getHeight();
        this.contentWidth = this.pageWidth - (2 * STYLE.margin);
        this.y = STYLE.margin;
    }

    public save(filename: string) {
        this.doc.save(filename);
    }

    public forceNewPage() {
        this.doc.addPage();
        this.y = STYLE.margin;
    }

    private checkPageBreak(neededSpace: number): boolean {
        if (this.y + neededSpace > this.pageHeight - STYLE.margin) {
            this.doc.addPage();
            this.y = STYLE.margin;
            return true;
        }
        return false;
    }

    public addTitlePage(title: string, subtitle: string) {
        this.y = this.pageHeight / 3;

        // Title
        this.doc.setFontSize(STYLE.sizes.title);
        this.doc.setFont(STYLE.fonts.bold, "bold");
        this.doc.setTextColor(...STYLE.colors.primary);
        const titleWidth = this.doc.getTextWidth(title);
        this.doc.text(title, (this.pageWidth - titleWidth) / 2, this.y, { charSpace: 0 });
        this.y += 12;

        // Subtitle
        this.doc.setFontSize(STYLE.sizes.subHeader);
        this.doc.setFont(STYLE.fonts.normal, "normal");
        this.doc.setTextColor(...STYLE.colors.meta);
        const subWidth = this.doc.getTextWidth(subtitle);
        this.doc.text(subtitle, (this.pageWidth - subWidth) / 2, this.y, { charSpace: 0 });
        this.y += 10;

        // Date
        const dateStr = `Generated: ${new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}`;
        const dateWidth = this.doc.getTextWidth(dateStr);
        this.doc.text(dateStr, (this.pageWidth - dateWidth) / 2, this.y, { charSpace: 0 });

        // Footer
        this.doc.setFontSize(STYLE.sizes.small);
        this.doc.setTextColor(...STYLE.colors.subtle);
        this.doc.text("Generated by Antigravity AI Research Tool", this.pageWidth / 2, this.pageHeight - 20, { align: "center", charSpace: 0 });

        this.forceNewPage();
    }

    public addSourceHeader(index: number, source: Source) {
        // Ensure space for the whole header block
        if (this.y + 30 > this.pageHeight - STYLE.margin) {
            this.forceNewPage();
        }

        // Background Box
        this.doc.setFillColor(...STYLE.colors.cardBG);
        this.doc.rect(STYLE.margin, this.y, this.contentWidth, 25, "F");

        this.y += 10;

        // Title
        this.doc.setFontSize(STYLE.sizes.header);
        this.doc.setFont(STYLE.fonts.bold, "bold");
        this.doc.setTextColor(...STYLE.colors.primary);
        this.doc.text(`${index}. ${source.title}`, STYLE.margin + 5, this.y, { charSpace: 0 });

        this.y += 8;

        // Meta
        this.doc.setFontSize(STYLE.sizes.meta);
        this.doc.setFont(STYLE.fonts.normal, "normal");
        this.doc.setTextColor(...STYLE.colors.meta);
        const metaText = `TYPE: ${source.type.toUpperCase()}  |  ADDED: ${source.addedDate}  |  STATUS: ${source.status}`;
        this.doc.text(metaText, STYLE.margin + 5, this.y, { charSpace: 0 });

        this.y += 15;
    }

    public addSectionHeader(title: string) {
        this.y += 6;
        this.checkPageBreak(25);

        this.doc.setFillColor(...STYLE.colors.accentBG);
        this.doc.rect(STYLE.margin, this.y - 5, this.contentWidth, 10, "F");

        this.doc.setFontSize(STYLE.sizes.section);
        this.doc.setFont(STYLE.fonts.bold, "bold");
        this.doc.setTextColor(...STYLE.colors.primary);
        this.doc.text(title.toUpperCase(), STYLE.margin + 3, this.y + 1.5, { charSpace: 0 });

        this.y += 10;
    }

    public addSubHeader(title: string) {
        this.y += 2;
        this.checkPageBreak(15);

        this.doc.setFontSize(STYLE.sizes.subHeader);
        this.doc.setFont(STYLE.fonts.bold, "bold");
        this.doc.setTextColor(...STYLE.colors.primary);
        this.doc.text(title, STYLE.margin, this.y, { charSpace: 0 });
        this.y += 6;

        // Underline
        this.doc.setDrawColor(...STYLE.colors.line);
        this.doc.setLineWidth(0.1);
        this.doc.line(STYLE.margin, this.y - 4, STYLE.margin + 50, this.y - 4);
    }

    public addText(text: string | null | undefined, color: [number, number, number] = STYLE.colors.text, indent: number = 0) {
        if (!text) return;

        const cleanContent = sanitizeText(text);

        this.doc.setFontSize(STYLE.sizes.body);
        this.doc.setTextColor(...color);
        this.doc.setFont(STYLE.fonts.normal, "normal");

        const paragraphs = cleanContent.split('\n');

        paragraphs.forEach((paragraph) => {
            let content = paragraph.replace(/\s+/g, " ").trim();
            if (!content) return;

            // Simplified: No special bullet logic, just render the text
            const currentIndent = indent;
            const availableWidth = this.contentWidth - currentIndent;

            const lines = this.doc.splitTextToSize(content, availableWidth);

            const lineHeightFactor = STYLE.spacing.lineHeight;
            const lineSpacing = STYLE.sizes.body * 0.45 * lineHeightFactor;
            const blockHeight = lines.length * lineSpacing + 2;

            this.checkPageBreak(blockHeight);

            // Draw Text Lines
            const xPos = STYLE.margin + currentIndent;
            lines.forEach((line: string, i: number) => {
                this.doc.text(line, xPos, this.y, { charSpace: 0, align: 'left' });
                if (i < lines.length - 1) {
                    this.y += lineSpacing;
                }
            });

            this.y += lineSpacing + STYLE.spacing.paragraph;
        });

        // Add a little extra space after a block
        this.y += 1;
    }

    public addFooter() {
        const totalPages = this.doc.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            this.doc.setPage(i);
            this.doc.setFontSize(STYLE.sizes.small);
            this.doc.setTextColor(...STYLE.colors.subtle);
            this.doc.text(
                `Page ${i} of ${totalPages}`,
                this.pageWidth / 2,
                this.pageHeight - 10,
                { align: "center", charSpace: 0 }
            );
        }
    }
}

// --- Main Export ---

export function generateFullReportPDF(sources: Source[]) {
    const generator = new ReportGenerator();

    // 1. Title Page
    generator.addTitlePage("Comprehensive Analysis Report", "Decolonial Situatedness in Global AI Governance");

    // 2. Filter Sources
    const analyzedSources = sources.filter(s =>
        s.analysis || s.cultural_framing || s.institutional_logics || s.legitimacy_analysis
    );

    if (analyzedSources.length === 0) {
        generator.addText("No completed analyses found. Please run an analysis on your documents first.");
        generator.save(`Analysis_Report_Empty.pdf`);
        return;
    }

    // 3. Iterate Sources
    analyzedSources.forEach((source, index) => {
        if (index > 0) {
            generator.forceNewPage();
        }

        // Source Header
        generator.addSourceHeader(index + 1, source);

        // 1. Cultural Framing
        if (source.cultural_framing) {
            generator.addSectionHeader("Cultural Framing Analysis");

            if (source.cultural_framing.state_market_society) {
                generator.addSubHeader("State-Market-Society Relations");
                generator.addText(source.cultural_framing.state_market_society, STYLE.colors.secondary);
            }
            if (source.cultural_framing.technology_role) {
                generator.addSubHeader("Role of Technology");
                generator.addText(source.cultural_framing.technology_role, STYLE.colors.secondary);
            }
            if (source.cultural_framing.rights_conception) {
                generator.addSubHeader("Conception of Rights");
                generator.addText(source.cultural_framing.rights_conception, STYLE.colors.secondary);
            }
            if (source.cultural_framing.dominant_cultural_logic) {
                generator.addSubHeader("Dominant Cultural Logic");
                generator.addText(source.cultural_framing.dominant_cultural_logic, STYLE.colors.secondary);
            }
        }

        // 2. Institutional Logics
        if (source.institutional_logics) {
            generator.addSectionHeader("Institutional Logics");

            if (source.institutional_logics.dominant_logic) {
                generator.addSubHeader("Dominant Logic");
                generator.addText(source.institutional_logics.dominant_logic, STYLE.colors.secondary);
            }

            if (source.institutional_logics.logics) {
                generator.addSubHeader("Logic Strengths");
                const l = source.institutional_logics.logics;
                let stats = "";
                if (l.market) stats += `• Market Logic: ${l.market.strength}/10\n`;
                if (l.state) stats += `• State Logic: ${l.state.strength}/10\n`;
                if (l.professional) stats += `• Professional Logic: ${l.professional.strength}/10\n`;
                if (l.community) stats += `• Community Logic: ${l.community.strength}/10`;
                generator.addText(stats, STYLE.colors.primary);
            }

            if (source.institutional_logics.logic_conflicts && source.institutional_logics.logic_conflicts.length > 0) {
                generator.addSubHeader("Key Institutional Conflicts");
                let conflicts = "";
                source.institutional_logics.logic_conflicts.forEach(c => {
                    conflicts += `• ${c.between}: ${c.site_of_conflict} (Resolution: ${c.resolution_strategy})\n`;
                });
                generator.addText(conflicts, STYLE.colors.secondary);
            }
        }

        // 3. Legitimacy Analysis
        if (source.legitimacy_analysis) {
            generator.addSectionHeader("Legitimacy Analysis");

            if (source.legitimacy_analysis.dominant_order) {
                let domOrder = source.legitimacy_analysis.dominant_order;
                // Type guard no longer strictly needed if type assumption holds, but good for safety if upstream sends odd data
                if (typeof domOrder === 'object') domOrder = "Mixed/Complex Orders";

                generator.addSubHeader("Dominant Order");
                generator.addText(domOrder, STYLE.colors.secondary);
            }

            if (source.legitimacy_analysis.orders) {
                const o = source.legitimacy_analysis.orders;
                generator.addSubHeader("Legitimacy Scores (0-10)");
                const scores = `• Market: ${o.market}   • Industrial: ${o.industrial}   • Civic: ${o.civic}\n• Domestic: ${o.domestic}   • Inspired: ${o.inspired}   • Fame: ${o.fame}`;
                generator.addText(scores, STYLE.colors.primary);
            }

            if (source.legitimacy_analysis.conflict_spot) {
                generator.addSubHeader("Conflict Spot");
                const conflict = source.legitimacy_analysis.conflict_spot;
                let conflictDesc = "";

                if (typeof conflict === 'string') {
                    conflictDesc = conflict;
                } else {
                    // Typed now, so we can access properties safely
                    if (conflict.course_of_action) conflictDesc += `Location: ${conflict.location}\n`; // Check if location exists in type? object has location
                    // Wait, previous code had `conflict.location` but my type update has `location`.
                    // My type update: { location: string; description: string; ... }
                    // So `conflict.location` is valid.
                    if (conflict.location && !conflict.course_of_action) conflictDesc += `Location: ${conflict.location}\n`;
                    if (conflict.description) conflictDesc += `${conflict.description}\n`;
                    if (conflict.resolution_strategy) conflictDesc += `Strategy: ${conflict.resolution_strategy}`;
                }
                generator.addText(conflictDesc, STYLE.colors.secondary);
            }
        }

        // 4. Governance Scores
        if (source.analysis && source.analysis.governance_scores) {
            generator.addSectionHeader("Governance Compass (DSF)");

            const g = source.analysis.governance_scores;
            generator.addSubHeader("Metric Scores");
            const gScores = `• Centralization: ${g.centralization}\n• Rights Focus: ${g.rights_focus}\n• Flexibility: ${g.flexibility}\n• Market Power: ${g.market_power}\n• Procedurality: ${g.procedurality}`;
            generator.addText(gScores, STYLE.colors.primary);

            if (source.analysis.key_insight) {
                generator.addSubHeader("Key Insight");
                generator.addText(source.analysis.key_insight, STYLE.colors.secondary);
            }

            if (source.analysis.governance_score_explanations) {
                generator.addSubHeader("Score Explanations");
                const e = source.analysis.governance_score_explanations;
                let expl = "";
                if (e.centralization) expl += `• Centralization: ${e.centralization}\n`;
                if (e.rights_focus) expl += `• Rights Focus: ${e.rights_focus}\n`;
                if (e.flexibility) expl += `• Flexibility: ${e.flexibility}`;
                generator.addText(expl, STYLE.colors.secondary);
            }
        }
    });

    generator.addFooter();
    generator.save(`Analysis_Report_${new Date().toISOString().split('T')[0]}.pdf`);
}
